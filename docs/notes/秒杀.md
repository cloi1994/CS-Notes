## 简介

高并发秒杀抢购系统设计介绍了在高并发场应用景中最容易出现的两个系统设计问题，一个涉及多进程多线程下的互斥问题，另一个涉及内存式缓存数据库的应用，具体内容涉及数据库乐观锁和悲观锁、队列的应用和高并发系统的四个衡量指标（并发数、QPS、TPS、响应时间）。

## Design

如果给你设计一个抢购系统，最容易想的处理思路是什么样的？看看是不是这样：

1、当有人来购买时，取出库存数据；

2、判断库存是否够；

3、如果够减掉库存，保存到数据库中；

4、反馈提示用户抢购成功。

<div align="center"> <img src="https://upload-images.jianshu.io/upload_images/9388586-7594f3cb78d300d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/207/format/webp"/> </div><br>

举例来看看。我们有数据库表记录商品库存，我们看看伪代码的实现。

<div align="center"> <img src="https://upload-images.jianshu.io/upload_images/9388586-9302aa7e47721dcc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp"/> </div><br>

## 超卖

1. 结果库存一定是负的吗？

    答案是否定，超卖最终库存不一定是负的，有可能是0，有可能是负的，也有可能是正的。
    
2. 为什么？
    目标系统的负载一般不是长时间高负载，它具有短时突发性，有可能在高峰过后，活跃用户少不形成高并发场景，最后结束的数值就可能是0也有可能是大于0。
    
下面有一段PHP按上面逻辑编写的代码，在多线程的情况下我们测试看看。设置库存100个，线程100个相当用户100个，先想一下库存数是多少就代表了会超卖？对，大于0一定就是超卖了。看下执行结果，库存大于0。也就是说100用户已经成功下单，库存应该是0并且系统显示已经抢光了才正确，但是还有剩余库存，也就说后来用户还可以下单，那么结果是一定超卖了。

这样的程序逻辑是不行的，那么我们想办法改进一下。问题是出在了对库存读取没有锁定，导致后续进程（或者线程）读出了同样的库存。我们可以使用数据库中的悲观锁来解决这个问题。

## 悲观锁

在正事务处理过程中，将数据锁定。锁定的是整个事务过程，也就是库存的整个读写过程。下面有一个利用mysql行级锁实现的简化悲观锁。

看结果，最终库存为0，因此不会超卖，理论上是可行的，是一个可选方案。

在突发高并发环境下并不能去使用。在有数据库应用的系统，在高负载情况下，各个组成部分，例如Web服务器（Nginx、Apache、IIS）、缓存数据库（Redis、Memcached）等等，数据库系统一般是最先达到负载饱和，也就是说前端访问压力直接穿透到数据库会让数据库最早出现访问瓶颈，最终数据库响应变慢，查询慢、写入慢甚至是服务无响应、宕机。在这种情况下，重启服务器也不能解决问题。因为在前端的访问压力在数据库重启后瞬间又传导到数据库，而且这种情况下，前端访问压力可能更大。我们是不是有这种操作系统，如果抢购系统迟迟没有响应，是不是会狂刷库存然后狂点下单？对，这种情况下会导致服务器产生更高的负载。这里有个词叫“雪崩效应”。什么是雪崩效应，在我们计算机应用系统里面因为某一台计算机产生错误异常导致应用系统服务异常，因而可能会让应用系统中的所有计算机崩溃，这种就是雪崩效应，非常恐怖，让应用系统彻底无法使用。

因为数据库会首先出现访问瓶颈，那我们再改进一下，改进的重点就是减缓数据库出现瓶颈的时间，因此引进缓存数据库，将操作非常频繁的数据在缓存中进行，然后将数据异步写回数据库。现在常用的缓存数据库，如Redis、Memcached，都是内存缓存，缓存的数据都是存放在内存中进行运算。将数据从传统数据库中拿到内存中运算，速度一定是很快，但是同时还要注意到要解决数据锁的问题，否则还会出现刚开始“超卖”的问题。在缓存数据库中解决锁的问题，缓存数据库提供了两种解决方式。第一个是乐观锁，第二个是队列。

## 乐观锁

是在需要加锁的数据上增加版本号，每次读取时同时读取版本号，当有更新是缓存中的版本号会发生变化，当提交更新时会比较读取时的版本号和最新的版本号，如果版本号不同则更新失败，版本号相同则更新成功。有乐观锁一张示意图。

乐观锁的常见应用是在我们常用的版本管理工具中，如SVN和Git。

在缓存中解决锁的问题，还有一种方式是队列，这种方式是将并行改串行。队列是什么样子的，先进先出，线性依次处理，用这种方式可以避免锁的问题。

<div align="center"> <img src="https://upload-images.jianshu.io/upload_images/9388586-0778ea874b976590.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp"/> </div><br>

为了要成功提交数据，这里用了一个循环，循环体里面，首先是获取数据版本号，读取数据，进行库存判断，处理数据，数据写回缓存的时候进行判断，直到成功为止。按这个实现逻辑，用PHP实现了一段多线程程序，依旧是100个商品库存，100个线程，我们看运行结果。执行最终结果库存是0，不会超卖。


## 队列

再来说一下队列的应用。在用户抢购后将抢购请求放入到队列中，服务器后端常驻服务进程处理队列中的任务。后端语言可以根据实际需要选用，不限语言。后端的处理程序要完成的处理任务大都是这几部分，处理抢购结果、记录抢购日志、抢购结果回写数据库。其中尤其要注意日志的记录，可能会在必要的时候起到非常重要的作用，日志一般是记录中文本中，介于内存和数据库之间。

抢购下单后，前端一般都是采用异步等待，响应时间一般要控制在10秒以内，前端可以Ajax等待回调或者定时获取抢购结果。

队列的应用就不具体再说，按照最先的处理思路都可以，就是因为队列是将并行改为串行，将请求一个一个依次处理。


## 衡量指标

1. 并发数、并发用户数
2. QPS - Query per Second(每秒查询率)是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准 - 最大吞吐能力
3. TPS - transactions Per Second（每秒传输的事物处理个数 - 包括了用户请求服务器，服务器内部处理，服务器返回信息给用户三个过程
4. 响应时间和平均响应时间


并发用户数，不应该省略掉后面的“用户”两个字，它本意是衡量系统可以承载多少活跃用户同时访问系统。

并发数是同时访问服务器站点的连接数，再换一种描述就是同时访问应用系统的用户数。这个指标是个测量值，不是测算值，是个比较笼统的指标，其他三个指标就是比较准备的测算值。



